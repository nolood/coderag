# CodeRAG: Улучшение UX и интеграции с LLM-агентами

## Контекст

CodeRAG — инструмент семантического поиска по коду, который интегрируется с LLM через MCP (Model Context Protocol). Основной сценарий использования: разработчик подключает CodeRAG к Claude, и Claude может искать релевантный код в проекте.

---

## Проблема 1: Избыточная церемония при настройке

### Текущее поведение

Чтобы начать использовать CodeRAG в проекте, пользователь должен:

1. Перейти в директорию проекта
2. Выполнить `coderag init` — создаётся папка `.coderag/`
3. Выполнить `coderag index` — индексируется код
4. Настроить MCP в Claude для этого проекта

При работе с 5-10 проектами это превращается в рутину. Забыл проиндексировать — поиск не работает. Переключился на другой проект — нужно помнить, инициализирован ли он.

### Почему это плохо

Инструмент позиционируется как «подключил к Claude и забыл». На практике — постоянно нужно помнить о состоянии индекса в каждом проекте. Это friction, который снижает adoption.

### Желаемое поведение

Пользователь ставит CodeRAG один раз, прописывает MCP конфигурацию один раз — и дальше просто работает. CodeRAG сам понимает, в каком проекте находится пользователь, и автоматически управляет индексами.

**Сценарий:**
```
Пользователь открывает терминал в ~/projects/new-app
Вызывает поиск через Claude или CLI
CodeRAG:
  → Видит, что cwd = ~/projects/new-app
  → Находит корень проекта (по .git, package.json, Cargo.toml и т.д.)
  → Проверяет, есть ли индекс для этого проекта
  → Если нет — создаёт автоматически
  → Если есть — проверяет актуальность, обновляет при необходимости
  → Выполняет поиск
```

### Ключевые изменения

**Глобальное хранилище индексов.** Вместо `.coderag/` в каждом проекте — централизованное хранилище в домашней директории (`~/.coderag/indexes/`). Каждый проект получает свою поддиректорию, идентифицируемую по пути.

**Автоматическое определение проекта.** При любом вызове CodeRAG определяет корень проекта по текущей директории. Ищет вверх по дереву маркеры: `.git`, `package.json`, `Cargo.toml`, `pyproject.toml`, `go.mod` и подобные.

**Автоматическая индексация.** Если проект ещё не индексирован — индексация происходит автоматически при первом обращении. Пользователь видит сообщение «Indexing project for the first time...» и через несколько секунд получает результат.

**Автоматическое обновление.** При повторных обращениях CodeRAG проверяет, изменились ли файлы с момента последней индексации. Если да — обновляет инкрементально.

**Опциональный локальный конфиг.** Если в проекте нужны особые настройки (игнорировать определённые папки, использовать другую модель эмбеддингов), можно создать `.coderag/config.toml` в проекте. Он переопределит глобальные настройки.

### Обратная совместимость

Проекты с существующей папкой `.coderag/` продолжают работать как раньше. Локальная конфигурация имеет приоритет над глобальной.

---

## Проблема 2: MCP недоступен в субагентах

### Контекст

В Claude Code есть механизм субагентов — через `Task()` можно запустить изолированную задачу, которую выполняет отдельный экземпляр Claude. Это используется для параллелизации работы и декомпозиции сложных задач.

### Текущее поведение

```
Главный Claude (имеет доступ к MCP инструментам CodeRAG)
  │
  └─ Запускает Task("Используй CodeRAG для поиска...")
       │
       └─ Субагент: "Инструмент mcp__coderag__search не найден"
          → Задача падает
```

Субагенты запускаются в изолированном контексте и не наследуют MCP-подключения от родительской сессии. Это ограничение архитектуры Claude Code.

### Почему это проблема

Типичный сценарий — оркестрация разработки фичи:

1. Главный агент анализирует задачу
2. Запускает несколько субагентов для параллельной работы
3. Каждый субагент должен искать релевантный код

На шаге 3 всё ломается, потому что субагенты не могут вызывать CodeRAG.

### Желаемое поведение

```
Главный Claude
  │
  ├─ Сам вызывает mcp__coderag__search("authentication")
  │    → Получает результаты: файлы, фрагменты кода, строки
  │
  └─ Запускает Task() с промптом:
       "Вот релевантный код из проекта:
        [вставлены результаты поиска]
        
        Проанализируй и предложи изменения..."
       │
       └─ Субагент работает с уже готовыми данными
          → Задача выполняется успешно
```

### Принцип решения

**Оркестратор — единственный, кто общается с MCP.** Главный агент (оркестратор) имеет доступ к CodeRAG и отвечает за получение всего необходимого контекста.

**Субагенты получают данные через промпт.** Вместо того чтобы давать субагентам инструкцию «найди код», оркестратор сам находит код и передаёт его субагентам как часть промпта.

**Субагенты работают с готовыми данными.** Субагент получает конкретные фрагменты кода, пути к файлам, номера строк — всё, что нужно для работы. Ему не нужно ничего искать.

### Паттерн использования

**Фаза 0 — Сбор контекста (выполняет оркестратор):**
- Оркестратор понимает, какая информация нужна для задачи
- Вызывает CodeRAG: поиск по ключевым словам, получение файлов
- Собирает релевантный контекст

**Фаза 1-N — Выполнение (субагенты):**
- Оркестратор запускает субагенты
- Каждый субагент получает в промпте готовый контекст
- Субагенты выполняют свою часть работы

### Важно

Это не баг CodeRAG, а ограничение архитектуры субагентов. Решение — на стороне того, кто пишет оркестрацию (промпты, команды). CodeRAG здесь не при чём, но понимание этого ограничения критично для правильного использования.

---

## Связь между проблемами

Проблемы независимые, но усиливают друг друга:

**Без global mode:** даже если оркестратор вызывает MCP, нужно убедиться, что текущий проект проинициализирован и проиндексирован. Дополнительная когнитивная нагрузка.

**С global mode:** оркестратор просто вызывает `mcp__coderag__search` — CodeRAG сам разберётся с проектом. Один барьер убран.

**Субагенты:** независимо от global mode, субагенты не получат MCP. Паттерн «оркестратор собирает контекст» нужен в любом случае.

---

---

## Проблема 3: Нет явного триггера для использования CodeRAG

### Контекст

У других MCP-инструментов есть понятные триггеры. Например, context7 активируется по фразе `use ...`. Пользователь явно сигнализирует: «сейчас нужен этот инструмент».

### Текущее поведение

CodeRAG не имеет явного триггера. Пользователь должен либо:
- Явно писать «найди в кодовой базе», «поищи в проекте»
- Надеяться, что Claude сам догадается использовать CodeRAG

Это ненадёжно. Claude может ответить из головы, использовать другой инструмент, или просто не понять, что нужен поиск по коду.

### Желаемое поведение

Два явных триггера:

**`use coderag`** — в начале или в контексте запроса
```
use coderag
Как у нас реализована авторизация?
```

**`@coderag`** — inline упоминание
```
@coderag найди все места где используется Redis
```

При обнаружении триггера активируется отдельный CodeRAG-агент, который:
1. Понимает, что нужно искать
2. Вызывает MCP инструменты CodeRAG
3. Возвращает релевантный контекст
4. Отвечает на вопрос с учётом найденного кода

### Почему отдельный агент

**Изоляция ответственности.** CodeRAG-агент специализируется на работе с кодовой базой. Он знает, как формулировать поисковые запросы, как интерпретировать результаты, когда нужен `search`, а когда `get_file`.

**Переиспользование.** Этот агент можно вызывать из разных контекстов — из основного чата, из других агентов (memory-агент), из оркестраторов.

**Простота интеграции.** Вместо того чтобы учить каждого агента работать с CodeRAG MCP, достаточно научить его вызывать CodeRAG-агента.

### Поведение агента

**Вход:** запрос пользователя + триггер (`use coderag` или `@coderag`)

**Процесс:**
1. Распарсить запрос, понять что искать
2. Вызвать `mcp__coderag__search` с релевантными ключевыми словами
3. Если нужно больше контекста — вызвать `mcp__coderag__get_file` для конкретных файлов
4. Если нужен обзор структуры — вызвать `mcp__coderag__list_files`
5. Синтезировать ответ на основе найденного кода

**Выход:** ответ на вопрос с цитатами из кода, ссылками на файлы и строки

### Примеры использования

```
User: use coderag
      Как работает аутентификация в нашем API?

Agent: [вызывает search("authentication API")]
       [получает результаты: auth.ts, middleware/jwt.ts, ...]
       [вызывает get_file для ключевых файлов]
       
       В проекте аутентификация реализована через JWT. 
       Основная логика в `src/auth/jwt.ts` (строки 45-80):
       - Middleware проверяет токен в заголовке Authorization
       - Валидация через библиотеку jose
       - При успехе добавляет user в request context
       ...
```

```
User: @coderag где используется Redis?

Agent: [вызывает search("Redis")]
       [вызывает list_files("**/redis*")]
       
       Redis используется в трёх местах:
       1. `src/cache/redis-client.ts` — инициализация подключения
       2. `src/session/store.ts` — хранение сессий (строки 20-45)
       3. `src/queue/worker.ts` — очередь задач
       ...
```

---

## Итог

### Что нужно изменить в CodeRAG

1. Добавить режим глобального хранилища индексов
2. Реализовать автоматическое определение проекта по cwd
3. Добавить автоматическую индексацию при первом обращении
4. Добавить проверку актуальности и инкрементальное обновление
5. Сохранить обратную совместимость с локальным `.coderag/`

### Что нужно создать для интеграции

1. Отдельный CodeRAG-агент, который умеет работать с MCP инструментами
2. Триггеры `use coderag` и `@coderag` для вызова этого агента
3. Агент должен уметь: искать, получать файлы, синтезировать ответы

### Паттерн использования в оркестраторах

Если оркестратор запускает субагенты через Task():
1. Оркестратор сам вызывает CodeRAG-агента (или MCP напрямую)
2. Получает контекст
3. Передаёт контекст субагентам через промпт
4. Субагенты работают с готовыми данными

---

## Критерии готовности

**Global mode работает, когда:**
- Пользователь может вызвать `coderag search` в любом проекте без предварительного init/index
- Индексы хранятся централизованно и не засоряют проекты
- Существующие проекты с `.coderag/` работают как раньше
- MCP сервер корректно определяет проект по cwd

**CodeRAG-агент работает, когда:**
- Триггеры `use coderag` и `@coderag` распознаются и запускают агента
- Агент корректно вызывает MCP инструменты (search, list_files, get_file)
- Агент синтезирует понятные ответы с ссылками на код
- Агент можно вызывать из других агентов (например, memory-агент)

**Интеграция с агентами работает, когда:**
- Документация явно описывает паттерн «оркестратор собирает контекст»
- Есть примеры правильного использования с субагентами
- Ошибка «MCP недоступен» не возникает при правильном использовании
